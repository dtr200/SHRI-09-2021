//module.exports = (amount, costsArray) => {
const f = (amount, costsArray) => {
    if(!amount) return '';

    /*
        Создаю массив уникальных цен и самым дальним позициям, которые соответствуют
        этим ценам. 
        Вид: [[5, 9], [4, 8], [3, 7], [2, 6], [1, 5]] для массива [5,4,3,2,1,2,3,4,5].
        Массив отсортирован по убыванию. Для этого создаю хеш-таблице prices, где 
        ключ это цена, значение это массив с позициями на которых встречается эта
        цена. Вторым проходом по объекту сортирую эти массивы от большего к меньшему 
        и оставляю только первое значение. Затем собираю все это в массив через entries.
        Массив сортирую по цене по убыванию.
        Беру последнее самое дешевое значение и делю количество денег amount на это
        значение, так я узнаю максимальное количество индексов, сколько я могу себе
        позволить. Округляю в меньшую сторону. 
        Если это число больше 0, то столько раз пушу в массив это число.
        Считаю сколько денег останется после всего этого - беру остаток от деления
        суммы денег на самый дешевый индекс.
        Сортирую массив nums по позиции по убыванию.
        Завожу переменную index, которая будет считать от 0 до макс. кол-ва индексов,
        сколько я смогу себе позволить maxNums. 
        Запускаю цикл while пока не закончатся экстра деньги и пока индекс не станет 
        равным maxNums.
        Внутри while создаю флаг и темп переменную, которая равна экстра деньгам + 
        цене одного самого дешевого индекса т.к. в случае нахождения подходящего 
        индекса, я выброшу один самый дешевый индекс и поставлю на его место новый
        найденный. Поставлю вперед т.к. он будет больше прошлых (они самые дешевые).
        Далее я меняю флаг на true т.к. что-то нашлось, убираю из экстра денег
        цену найденного индекса, прекращаю данный проход цикла for и если экстра 
        деньги все еще есть иду по второму кругу. Как только проход цикла for 
        завершится и ничего не будет найдено (flag останется false), то цикл while
        можно прекращать и возвращать результат.
    */

    const prices = {};
    costsArray.forEach((price, i) => {
        if(!prices[price]){
            prices[price] = [i + 1];
            return;
        }
        prices[price].push(i + 1);
    });
    for(let key in prices){
        prices[key].sort((a, b) => b - a);
        prices[key] = prices[key][0]; 
    }

    const nums = Object.entries(prices)
        .sort((a, b) => Number(b[0]) - Number(a[0]));
        
    const maxNums = Math.floor(amount/Number(nums[nums.length -1][0]));
    const selected = nums[nums.length -1][0];
    const result = [];
    
    if(maxNums > 0){
        for(let i = 0; i < maxNums; i++)
            result.push(nums[nums.length -1][1]);
    }
    let extra = amount % nums[nums.length -1][0];
    nums.sort((a, b) => Number(b[1]) - Number(a[1]));
    let index = 0;

    while(extra > 0 && index < maxNums){
        let flag = false,
            temp = extra + Number(selected);

        for(let i = 0; i < nums.length; i++){
            if(Number(nums[i][0]) <= temp && nums[i][1] > nums[nums.length -1][1]){
                result[index] = nums[i][1];
                index++;
                extra = temp - nums[i][0];
                flag = true;
                break;
            }
        }
        if(!flag)
            break;
    }
    return result.length === 0 ? '' : result.join(''); 
}

f(11, [5,4,3,2,2,2,3,4,5])